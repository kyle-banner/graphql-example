import { injectable } from 'inversify';
import { getRepository } from 'typeorm';
import IEmployeesService from './employees.interface';
import EmployeeDto from 'src/dto/Employee';
import { employee as employeeEntityToDomainMapper } from '../../util/mapper/entityToDomain';
import { employee as employeeDomainToEntityMapper } from '../../util/mapper/domainToEntity';
import { Employee as EmployeeEntity } from '../../entity/Employee';
import employeeMocks from './employeeMocks';

@injectable()
class EmployeesService implements IEmployeesService {
  private employeeRepository = process.env.MOCKS ? undefined : getRepository(EmployeeEntity);

  async getEmployees(): Promise<EmployeeDto[]> {
    if(process.env.MOCKS) {
      return employeeMocks.employeesMock();
    }

    // @ts-ignore
    const employeeEntities = await this.employeeRepository.find();
    if (employeeEntities.length) {
      const employeeDtos: EmployeeDto[] = [];
      employeeEntities.forEach((entity) => {
        employeeDtos.push(employeeEntityToDomainMapper.map(entity));
      });
      return employeeDtos;
    }
    return [];
  }

  async getEmployeeById(id: string): Promise<EmployeeDto | undefined> {
    if(process.env.MOCKS) {
      return employeeMocks.employeeMock();
    }

    // @ts-ignore
    const employeeEntity = await this.employeeRepository.findOne(id);
    if (employeeEntity) return employeeEntityToDomainMapper.map(employeeEntity);
    return undefined;
  }

  async createEmployee(createEmployeeRequest: EmployeeDto): Promise<EmployeeDto> {
    if(process.env.MOCKS) {
      return employeeMocks.employeeMock();
    }

    const employeeEntity = employeeDomainToEntityMapper.map(createEmployeeRequest);

    // @ts-ignore
    const entityResponse = await this.employeeRepository.save(employeeEntity);
    return employeeEntityToDomainMapper.map(entityResponse);
  }

  async updateEmployee(updateEmployeeRequest: EmployeeDto): Promise<EmployeeDto> {
    if(process.env.MOCKS) {
      return updateEmployeeRequest;
    }
    const employeeEntityToSave = employeeDomainToEntityMapper.map(updateEmployeeRequest);

    // @ts-ignore
    const employeeEntity = await this.employeeRepository.findOne(employeeEntityToSave.id);
    let updatedEmployeeEntity: EmployeeEntity;
    if (employeeEntity && employeeEntity.id) {
      // @ts-ignore
      await this.employeeRepository.update(employeeEntity.id, employeeEntityToSave);
      updatedEmployeeEntity = employeeEntityToSave;
    } else {
      delete employeeEntityToSave.id; // id is generated by the entity
      // @ts-ignore
      updatedEmployeeEntity = await this.employeeRepository.save(employeeEntityToSave);
    }
    return employeeEntityToDomainMapper.map(updatedEmployeeEntity);
  }

  async deleteEmployee(id: string): Promise<EmployeeDto | undefined> {
    if(process.env.MOCKS) {
      return employeeMocks.employeeMock();
    }

    // @ts-ignore
    const employeeEntity = await this.employeeRepository.findOne(id);
    if (employeeEntity) {
      // @ts-ignore
      await this.employeeRepository.remove(employeeEntity);
      return employeeEntityToDomainMapper.map(employeeEntity);
    }
    return undefined;
  }
}

export default EmployeesService;
